 A string literal or anonymous string is the representation of a string value within the source code of a computer program. Most often in modern languages this is a quoted sequence of characters (formally "bracketed delimiters"), as in x = "foo", where "foo" is a string literal with value foo – the quotes are not part of the value, and one must use a method such as escape characters to avoid the problem of delimiter collision and allow the delimiters themselves to be embedded in a string. However, there are numerous alternate notations for specifying string literals, particularly more complicated cases, and the exact notation depends on the individual programming language in question. Nevertheless, there are some general guidelines that most modern programming languages follow. Most modern programming languages use bracket delimiters (also balanced delimiters) to specify string literals. Double quotations are the most common quoting delimiters used: "Hi There!"  An empty string is literally written by a pair of quotes with no character at all in between: ""  Some languages either allow or mandate the use of single quotations instead of double quotations (the string must begin and end with the same kind of quotation mark and the type of quotation mark may give slightly different semantics): 'Hi There!'  Note that these quotation marks are unpaired (the same character is used as an opener and a closer), which is a hangover from the typewriter technology which was the precursor of the earliest computer input and output devices. In terms of regular expressions, a basic quoted string literal is given as: "[^"]*" This means that a string literal is written as: a quote, followed by zero, one, or more non-quote characters, followed by a quote. In practice this is often complicated by escaping, other delimiters, and excluding newlines. A number of languages provide for paired delimiters, where the opening and closing delimiters are different. These also often allow nested strings, so delimiters can be embedded, so long as they are paired, but still results in delimiter collision for embedding an unpaired closing delimiter. Examples include PostScript, which uses parentheses, as in (The quick (brown fox)) and m4, which uses the backtick (`) as the starting delimiter, and the apostrophe (') as the ending delimiter. Tcl allows both quotes (for interpolated strings) and braces (for raw strings), as in "The quick brown fox" or {The quick {brown fox}}; this derives from the single quotations in Unix shells and the use of braces in C for compound statements, since blocks of code is in Tcl syntactically the same thing as string literals – that the delimiters are paired is essential for making this feasible. While the Unicode character set includes paired (separate opening and closing) versions of both single and double quotations, used in text, mostly in other languages than English, these are rarely used in programming languages (because ASCII is preferred, and these are not included in ASCII): “Hi There!”   ‘Hi There!’   „Hi There!“   «Hi There!»  The paired double quotations can be used in Visual Basic .NET, but many other programming languages will not accept them. Unpaired marks are preferred for compatibility - , and so even in languages where they are permitted, many projects forbid their use for source code. String literals might be ended by newlines. One example is Wikipedia template parameters.   {{Navbox  |name=Nulls  |title=[[wikt:Null|Nulls]] in [[computing]]  }}  There might be special syntax for multi-line strings. In YAML, string literals may be specified by the relative positioning of whitespace and indentation.  - title: An example multi-line string in YAML       body : |         This is a multi-line string.         "special" metacharacters may         appear here. The extent of this string is         indicated by indentation. In the original FORTRAN programming language (for example), string literals were written in so-called Hollerith notation, where a decimal count of the number of characters was followed by the letter H, and then the characters of the string: 35HAn example Hollerith string literal  This declarative notation style is contrasted with bracketed delimiter quoting, because it does not require the use of balanced "bracketed" characters on either side of the string. Advantages: Drawbacks: This is however not a drawback when the prefix is generated by an algorithm as most likely the case When using quoting, if one wishes to represent the delimiter itself in a string literal, one runs into the problem of delimiter collision. For example, if the delimiter is a double quote, one cannot simply represent a double quote itself by the literal """ as the second quote in interpreted as the end of the string literal, not as the value of the string, and similarly one cannot write "This is "in quotes", but invalid." as the middle quoted portion is instead interpreted as outside of quotes. There are various solutions, the most general-purpose of which is using escape sequences, such as "\"" or "This is \"in quotes\" and properly escaped.", but there are many other solutions. Note that paired quotes, such as braces in Tcl, allow nested string, such as {foo {bar} zork} but do not otherwise solve the problem of delimiter collision, since an unbalanced closing delimiter cannot simply be included, as in {}}. A number of languages, including Pascal, BASIC, DCL, Smalltalk, SQL, and Fortran, avoid delimiter collision by doubling up on the quotation marks that are intended to be part of the string literal itself: 'This Pascal stringcontains two apostrophes'   "I said, ""Can you hear me?""" Some languages, such as Fortran, Modula-2, JavaScript, Python, and PHP allow more than one quoting delimiter; in the case of two possible delimiters, this is known as dual quoting. Typically, this consists of allowing the programmer to use either single quotations or double quotations interchangeably – each literal must use one or the other. "This is John's apple."   'I said, "Can you hear me?"' This does not allow having a single literal with both delimiters in it, however. This can be worked around by using several literals and using string concatenation:  'I said, "This is ' + "John's" + ' apple."'  Note that Python has string literal concatenation, so consecutive string literals are concatenated even without an operator, so this can be reduced to:  'I said, "This is '"John's"' apple."' D supports a few quoting delimiters, with such strings starting with q"[ and ending with ]" or similarly for other delimiter character (any of ()  {} or []). D also supports here document-style strings via similar syntax. In some programming languages, such as sh and Perl, there are different delimiters that are treated differently, such as doing string interpolation or not, and thus care must be taken when choosing which delimiter to use; see different kinds of strings, below. A further extension is the use of multiple quoting, which allows the author to choose which characters should specify the bounds of a string literal. For example in Perl:  qq^I said, "Can you hear me?"^ qq@I said, "Can you hear me?"@ qq§I said, "Can you hear me?"§  all produce the desired result. Although this notation is more flexible, few languages support it; other than Perl, Ruby (influenced by Perl) and C++11 also support these. In C++11, raw strings can have various delimiters, beginning with R"delimiter( and end with )delimiter". The delimiter can be from zero to 16 characters long and may contain any member of the basic source character set except whitespace characters, parentheses, or backslash. A variant of multiple quoting is the use of here document-style strings. Lua (as of 5.1) provides a limited form of multiple quoting, particularly to allow nesting of long comments or embedded strings. Normally one uses  and  to delimit literal strings (initial newline stripped, otherwise raw), but the opening brackets can include any number of equal signs, and only closing brackets with the same number of signs closed the string. For example:  local ls = [=[ This notation can be used for Windows paths:  local path = C:\Windows\Fonts ]=]  Multiple quoting is particularly useful with regular expressions that contain usual delimiters such as quotes, as this avoids needing to escape them. An early example is sed, where in the substitution command s/regex/replacement/ the default slash / delimiters can be replaced by another character, as in s,regex,replacement, . Another option, which is rarely used in modern languages, is to use a function to construct a string, rather than representing it via a literal. This is generally not used in modern languages because the computation is done at run time, rather than at parse time. For example, early forms of BASIC did not include escape sequences or any other workarounds listed here, and thus one instead was required to use the CHR$ function, which returns a string containing the character corresponding to its argument. In ASCII the quotation mark has the value 34, so to represent a string with quotes on an ASCII system one would write  "I said, " + CHR$(34) + "Can you hear me?" + CHR$(34)  In C, a similar facility is available via sprintf and the %c "character" format specifier, though in the presence of other workaround this is generally not used:  sprintf("This is %cin quotes.%c", 34, 34);  These constructor functions can also be used to represent nonprinting characters, though escape sequences are generally used instead. A similar technique can be used in C++ with the std::string stringification operator.  Escape sequences are a general technique for represent characters that are otherwise difficult to represent directly, including delimiters, nonprinting characters (such as backspaces), newlines, and whitespace characters (which are otherwise impossible to distinguish visually), and have a long history. They are accordingly widely used in string literals, and adding an escape sequence (either to a single character or throughout a string) is known as escaping. One character is chosen as a prefix to give encodings for characters that are difficult or impossible to include directly. Most commonly this is backslash; in addition to other characters, a key point is that backslash itself can be encoded as a double backslash \\ and for delimited strings the delimiter itself can be encoded by escaping, say by \" for ". A regular expression for such escaped strings can be given as follows, as found in the ANSI C specification:ANSI C grammar, Lex specification, STRING-LITERAL "(\.|[^\"])*" meaning "a quote; followed by zero or more of either an escaped character (backslash followed by something, possibly backslash or quote), or a non-escape, non-quote character; ending in a quote" – the only issue is distinguishing the terminating quote from a quote preceded by a backslash, which may itself be escaped. Note that multiple characters can follow the backslash, such as \uFFFF, depending on the escaping scheme. An escaped string must then itself be lexically analyzed, converting the escaped string into the unescaped string that it represents. This is done during the evaluation phase of the overall lexing of the computer language: the evaluator of the lexer of the overall language executes its own lexer for escaped string literals. Among other things, it must be possible to encode the character that normally terminates the string constant, plus there must be some way to specify the escape character itself. Escape sequences are not always pretty or easy to use, so many compilers also offer other means of solving the common problems.  Escape sequences, however, solve every delimiter problem and most compilers interpret escape sequences.  When an escape character is inside a string literal, it means "this is the start of the escape sequence".  Every escape sequence specifies one character which is to be placed directly into the string.  The actual number of characters required in an escape sequence varies.  The escape character is on the top/left of the keyboard, but the editor will translate it, therefore it is not directly tapeable into a string. The backslash is used to represent the escape character in a string literal. Many languages support the use of metacharacters inside string literals. Metacharacters have varying interpretations depending on the context and language, but are generally a kind of 'processing command' for representing printing or nonprinting characters. For instance, in a C string literal, if the backslash is followed by a letter such as "b", "n" or "t", then this represents a nonprinting backspace, newline or tab character respectively. Or if the backslash is followed by 1-3 octal digits, then this sequence is interpreted as representing the arbitrary character with the specified ASCII code. This was later extended to allow more modern hexadecimal character code notation: "I said,\t\t\x22Can you hear me?\x22\n" Note:  Not all sequences in the above list are supported by all parsers, and there may be other escape sequences which are not in the above list. When code in one programming language is embedded inside another, embedded strings may require multiple levels of escaping. This is particularly common in regular expressions and SQL query within other languages, or other languages inside shell scripts. This double-escaping is often difficult to read and author. Incorrect quoting of nested strings can present a security vulnerability. Use of untrusted data, as in data fields of an SQL query, should use prepared statements to prevent a code injection attack. In PHP 2 through 5.3, there was a feature called magic quotes which automatically escaped strings (for convenience and security), but due to problems was removed from version 5.4 onward. A few languages provide a method of specifying that a literal is to be processed without any language-specific interpretation. This avoids the need for escaping, and yields more legible strings. Raw strings are particularly useful when a common character needs to be escaped, notably in regular expressions (nested as string literals), where backslash \ is widely used, and in DOS/Windows paths, where backslash is used as a path separator. The profusion of backslashes is known as leaning toothpick syndrome, and can be reduced by using raw strings. Compare escaped and raw pathnames:  "The Windows path is C:\\Foo\\Bar\\Baz\\"  @"The Windows path is C:\Foo\Bar\Baz\"  Extreme examples occur when these are combined – Uniform Naming Convention paths begin with \\, and thus an escaped regular expression matching a UNC name begins with 8 backslashes, "\\\\\\\\", due to needing to escape the string and the regular expression. Using raw strings reduces this to 4 (escaping in the regular expression), as in C# @"\\\\". In XML documents, CDATA sections allows use of characters such as & and &lt; without an XML parser attempting to interpret them as part of the structure of the document itself. This can be useful when including literal text and scripting code, to keep the document well formed.    In many languages, string literals can contain literal newlines, spanning several lines. Alternatively, newlines can be escaped, most often as \n. For example:  echo 'foo bar'  and  echo -e "foo\nbar"  are both valid bash, producing: foo  bar Languages that allow literal newlines include bash, Lua, Perl, R, and Tcl. In some other languages string literals cannot include newlines. Two problems with multiline string literals are leading and trailing newlines, and indentation. If the initial or final delimiters are on separate lines, there are extra newlines, while if they are not, the delimiter makes the string harder to read, particularly for the first line, which is often indented differently from the rest. Further, the literal must be unindented, as leading whitespace is preserved – this breaks the flow of the code if the literal occurs within indented code. The most common solution for these problems is here document-style string literals. Formally speaking, a here document is not a string literal, but instead a stream literal or file literal. These originate in shell scripts and allow a literal to be fed as input to an external command. The opening delimiter is &lt;&lt;END where END can be any word, and the closing delimiter is END on a line by itself, serving as a content boundary – the &lt;&lt; is due to redirecting stdin from the literal. Due to the delimiter being arbitrary, these also avoid the problem of delimiter collision. These also allow initial tabs to be stripped via the variant syntax &lt;&lt;-END though leading spaces are not stripped. The same syntax has since been adopted for multiline string literals in a number of languages, most notably Perl, and are also referred to as here documents, and retain the syntax, despite being strings and not involving redirection. As with other string literals, these can sometimes have different behavior specified, such as variable interpolation. Python, whose usual string literals do not allow literal newlines, instead has a special form of string, designed for multiline literals, called triple quoting. These use a tripled delimiter, either ''' or """. These literals strip leading indentation and the trailing newline (but not the leading newline), and are especially used for inline documentation, known as docstrings. Tcl allows literal newlines in strings and has no special syntax to assist with multiline strings, though delimiters can be placed on lines by themselves and leading and trailing newlines stripped via string trim, while string map can be used to strip indentation. A few languages provide string literal concatenation, where adjacent string literals are implicitly joined into a single literal at compile time. This is a feature of C,C11 draft standard, WG14 N1570 Committee Draft — April 12, 2011, 5.1.1.2 Translation phases, p. 11: "6. Adjacent string literal tokens are concatenated."C syntax: String literal concatenation C++,C++11 draft standard, , 2.2 Phases of translation [lex.phases], p. 17: "6. Adjacent string literal tokens are concatenated." and 2.14.5 String literals [lex.string], note 13, p. 28–29: "In translation phase 6 (2.2), adjacent string literals are concatenated." D,D Programming Language, Lexical Analysis, "String Literals": "Adjacent strings are concatenated with the ~ operator, or by simple juxtaposition:" and Python,The Python Language Reference, 2. Lexical analysis, 2.4.2. String literal concatenation: "Multiple adjacent string literals (delimited by whitespace), possibly using different quoting conventions, are allowed, and their meaning is the same as their concatenation." which copied it from C.Python-ideas, "Implicit string literal concatenation considered harmful?", Guido van Rossum, May 10, 2013 Notably, this concatenation happens at compile time, during lexical analysis (as a phase following initial tokenization), and is contrasted with both run time string concatenation (generally with the + operator)The Python Language Reference, 2. Lexical analysis, 2.4.2. String literal concatenation: "Note that this feature is defined at the syntactical level, but implemented at compile time. The ‘+’ operator must be used to concatenate string expressions at run time." and concatenation during constant folding, which occurs at compile time, but in a later phase (after phrase analysis or "parsing"). Most languages, such as C#, Java"Strings", The Java Tutorial and Perl, do not support implicit string literal concatenation, and instead require explicit concatenation, such as with the + operator (this is also possible in D and Python, but illegal in C/C++ – see below); in this case concatenation may happen at compile time, via constant folding, or may be deferred to run time. In C, where the concept and term originate, string literal concatenation was introduced for two reasons:, 3.1.4 String literals: "A long string can be continued across multiple lines by using the backslash-newline line continuation, but this practice requires that the continuation of the string start in the first position of the next line.  To permit more flexible layout, and to solve some preprocessing problems (see §3.8.3), the Committee introduced string literal concatenation.  Two string literals in a row are pasted together (with no null character in the middle)  to make one combined string literal.  This addition to the C language allows a programmer to extend a string literal beyond the end of a physical line without having to use the backslash-newline mechanism and thereby destroying the indentation scheme of the program.  An explicit concatenation operator was not introduced because the concatenation is a lexical construct rather than a run-time operation." In practical terms, this allows string concatenation in early phases of compilation ("translation", specifically as part of lexical analysis), without requiring phrase analysis or constant folding. For example, the following are valid C/C++:  char *s = "hello, " "world"; printf("hello, " "world");  However, the following are invalid:  char *s = "hello, " + "world"; printf("hello, " + "world");  This is because string literals have pointer type, char * (C) or const char [n] (C++), which cannot be added; this is not a restriction in most other languages. This is particularly important when used in combination with the C preprocessor, to allow strings to be computed following preprocessing, particularly in macros. As a simple example:  char *file_and_message = __FILE__ ": message";  will (if the file is called a.c) expand to:  char *file_and_message = "a.c" ": message";  which is then concatenated, being equivalent to:  char *file_and_message = "a.c: message";  A common use case is in constructing printf or scanf format strings, where format specifiers are given by macros.C/C++ Users Journal, Volume 19, p. 50StackOverflow, "Why allow concatenation of string literals?" A more complex example uses stringification of integers (by the preprocessor) to define a macro that expands to a sequence of string literals, which are then concatenated to a single string literal with the file name and line number:Using __FILE__ and __LINE__ to Report Errors, by Curtis Krauskopf  Beyond syntactic requirements of C/C++, implicit concatenation is a form of syntactic sugar, making it simpler to split string literals across several lines, avoiding the need for line continuation (via backslashes) and allowing one to add comments to parts of strings. For example in Python, one can comment a regular expression in this way:The Python Language Reference, 2. Lexical analysis, 2.4.2. String literal concatenation: "This feature can be used to reduce the number of backslashes needed, to split long strings conveniently across long lines, or even to add comments to parts of strings, for example:  re.compile("[A-Za-z_]"       # letter or underscore "[A-Za-z0-9_]*"   # letter, digit or underscore           ) Implicit string concatenation is not required by modern compilers, which implement constant folding, and causes hard-to-spot errors due to unintentional concatenation from omitting a comma, particularly in vertical lists of strings, as in:  l = ['foo', 'bar'      'zork']  Accordingly, it is not used in most languages, and it has been proposed for deprecation from DDLang's Issue Tracking System – Issue 3827 - Warn against and then deprecate implicit concatenation of adjacent string literals and Python. However, removing the feature breaks backwards compatibility, and replacing it with a concatenation operator introduces issues of precedence – string literal concatenation occurs during lexing, prior to operator evaluation, but concatenation via an explicit operator occurs at the same time as other operators, hence precedence is an issue, potentially requiring parentheses to ensure desired evaluation order. A subtler issue is that in C and C++,C++11 draft standard, , 2.14.5 String literals [lex.string], note 13, p. 28–29: "Any other concatenations are conditionally supported with implementation-deﬁned behavior." there are different types of string literals, and concatenation of these has implementation-defined behavior, which poses a potential security risk.STR10-C. Do not concatenate different type of string literals Some languages provide more than one kind of literal, which have different behavior. This is particularly used to indicate raw strings (no escaping), or to disable or enable variable interpolation, but has other uses, such as distinguishing character sets. Most often this is done by changing the quoting character or adding a prefix. This is comparable to prefixes and suffixes to integer literals, such as to indicate hexadecimal numbers or long integers. One of the oldest examples is in shell scripts, where single quotes indicate a raw string or "literal string", while double quotes have escape sequences and variable interpolation. For example, in Python, raw strings are preceded by an r or R – compare 'C:\\Windows' with r'C:\Windows' (though, a Python raw string cannot end in an odd number of backslashes). Python 2 also distinguishes two types of strings: 8-bit ASCII ("bytes") strings (the default), explicitly indicated with a b or B prefix, and Unicode strings, indicated with a u or U prefix.2.4.1 String literals C#'s notation for raw strings is called @-quoting.  @"C:\Foo\Bar\Baz\"  While this disables escaping, it allows double-up quotes, which allow one to represent quotes within the string:  @"I said, ""Hello there."""  C++11 allows raw strings, unicode strings (UTF-8, UTF-16, and UTF-32), and wide character strings, determined by prefixes. In Tcl, brace-delimited strings are literal, while quote-delimited strings have escaping and interpolation. Perl has a wide variety of strings, which are more formally considered operators, and are known as quote and quote-like operators. These include both a usual syntax (fixed delimiters) and a generic syntax, which allows a choice of delimiters; these include:Quote and Quote-like Operators    ""  ``  //  m//  qr//  s///  y/// q{}  qq{}  qx{}  qw{}  m{}  qr{}  s{}{}  tr{}{}  y{}{}  REXX uses suffix characters to specify characters or strings using their hexadecimal or binary code. E.g.,  '20'x "0010 0000"b "00100000"b  all yield the space character, avoiding the function call X2C(20).  Languages differ on whether and how to interpret string literals as either 'raw' or 'variable interpolated'. Variable interpolation is the process of evaluating an expression containing one or more variables, and returning  output where the variables are replaced with their corresponding values in  memory. In sh-compatible Unix shells, quotation-delimited (") strings are interpolated, while apostrophe-delimited (') strings are not. For example, the following Perl code:  $name     = "Nancy"; $greeting = "Hello World"; print "$name said $greeting to the crowd of people.";  produces the output: Nancy said Hello World to the crowd of people.  The sigil character ($) is interpreted to indicate variable interpolation. Similarly, the printf function produces the same output using notation such as: printf "%s said %s to the crowd of people.", $name, $greeting; The metacharacters (%s) indicate variable interpolation. This is contrasted with "raw" strings: print '$name said $greeting to the crowd of people.'; which produce output like: $name said $greeting to the crowd of people.  Here the $ characters are not sigils, and are not interpreted to have any meaning other than plain text. Languages that lack flexibility in specifying string literals make it particularly cumbersome to write programming code that generates other programming code. This is particularly true when the generation language is the same or similar to the output language. For example: Nevertheless, some languages are particularly well-adapted to produce this sort of self-similar output, especially those that support multiple options for avoiding delimiter collision. Using string literals as code that generates other code may have adverse security implications, especially if the output is based at least partially on untrusted user input. This is particularly acute in the case of Web-based applications, where malicious users can take advantage of such weaknesses to subvert the operation of the application, for example by mounting an SQL injection attack. Escape Sequence !! Unicode !! Literal Characters placed into string \0 U+0000 null characterhttp://book.realworldhaskell.org/read/characters-strings-and-escaping-rules.htmlhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String \a U+0007 alerthttp://msdn.microsoft.com/en-us/library/h21280bw(v=vs.80).aspx \b U+0008 backspace \f U+000C form feed \n U+000A line feed (or newline in POSIX) \r U+000D carriage return (or newline in Mac OS 9 and earlier) \t U+0009 horizontal tab \v U+000B vertical tab \u#### U+#### 16-bit Unicode character where # is a hex digit \U######## U+######## 32-bit Unicode character where # is a hex digit (note that Unicode only supports 21-bit characters, so the first two digits are always zero) \u{######} U+###### 21-bit Unicode character where # is a hex digit, number of digits in {} is variable \x## U+00## 8-bit character specification where # is a hex digit \ooo U+00## 8-bit character specification where o is an octal digit \" U+0022 double quote (") \& non-character used to delimit numeric escapes in Haskell \' U+0027 single quote (') \\ U+005C backslash (\) \? U+003F question mark (?) eliminates text searching (for the delimiter character) and therefore requires significantly less overhead avoids the problem of delimiter collision enables the inclusion of metacharacters that might otherwise be mistaken as commands can be used for quite effective data compression of plain text strings this type of notation is error-prone if used as manual entry by programmers special care is needed in case of multi byte encodings To allow long strings to span multiple lines with proper indentation – in contrast to line continuation, which destroys the indentation scheme; and To allow the construction of string literals by macros (via stringizing)., 3.8.3.2 The # operator: "The # operator has been introduced for stringizing.  It may only be used in a #define expansion.  It causes the formal parameter name following to be replaced by a string literal formed by stringizing the actual argument token sequence.  In conjunction with string literal concatenation (see §3.1.4), use of this operator permits the construction of strings as effectively as by identifier replacement within a string.  An example in the Standard illustrates this feature." define STRINGIFY(x) #x define TOSTRING(x) STRINGIFY(x) define AT __FILE__ ":" TOSTRING(__LINE__) writing code to produce quines generating an output language from within a web template; using XSLT to generate XSLT, or SQL to generate more SQL generating a PostScript representation of a document for printing purposes, from within a document-processing application written in C or some other language. writing shaders Character literal Sigil (computer programming) Literals In Programming
