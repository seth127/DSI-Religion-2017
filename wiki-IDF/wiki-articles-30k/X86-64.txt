    x86-64 (also known as x64, x86_64 and AMD64) is the 64-bit version of the x86 instruction set. It supports vastly larger amounts (theoretically, 264&nbsp;bytes or 16&nbsp;exbibytes) of virtual memory and physical memory than is possible on its 32-bit predecessors, allowing programs to store larger amounts of data in memory. x86-64 also provides 64-bit general-purpose registers and numerous other enhancements. It is fully backward compatible with the 16-bit and 32-bit x86 code. Because the full x86 16-bit and 32-bit instruction sets remain implemented in hardware without any intervening emulation, existing x86 executables run with no compatibility or performance penalties, whereas existing applications that are recoded to take advantage of new features of the processor design may achieve performance improvements. The original specification, created by AMD and released in 2000, has been implemented by AMD, Intel and VIA. Various names are used for the instruction set; prior to the launch, x86-64 and x86_64 were used, while upon the release AMD named it AMD64. Intel initially used the names IA-32e and EM64T before finally settling on "Intel 64" for its implementation. Some in the industry, including Apple, use x86-64 and x86_64, while others, notably Sun Microsystems (now Oracle Corporation) and Microsoft, use x64. The BSD family of OSs and several Linux distributions use AMD64, and so does Microsoft Windows internally. The AMD K8 processor was the first to implement the architecture; this was the first significant addition to the x86 architecture designed by a company other than Intel. Intel was forced to follow suit and introduced a modified NetBurst family which was fully software-compatible with AMD's design and specification. VIA Technologies introduced x86-64 in their VIA Isaiah architecture, with the VIA Nano. The x86-64 specification is distinct from the Intel Itanium (formerly IA-64) architecture, which is not compatible on the native instruction set level with the x86 architecture. AMD64 was created as an alternative to the radically different IA-64 architecture, which was designed by Intel and Hewlett Packard. Originally announced in 1999 while a full specification became available in August 2000, the AMD64 architecture was positioned by AMD from the beginning as an evolutionary way to add 64-bit computing capabilities to the existing x86 architecture, as opposed to Intel's approach of creating an entirely new 64-bit architecture with IA-64. The first AMD64-based processor, the Opteron, was released in April 2003. AMD's processors implementing the AMD64 architecture include Opteron, Athlon 64, Athlon 64 X2, Athlon 64 FX, Athlon II (followed by "X2", "X3", or "X4" to indicate the number of cores, and XLT models), Turion 64, Turion 64 X2, Sempron ("Palermo" E6 stepping and all "Manila" models), Phenom (followed by "X3" or "X4" to indicate the number of cores), Phenom II (followed by "X2", "X3", "X4" or "X6" to indicate the number of cores), FX, and Fusion. The primary defining characteristic of AMD64 is the availability of 64-bit general-purpose processor registers (for example, rax and rbx), 64-bit integer arithmetic and logical operations, and 64-bit virtual addresses. The designers took the opportunity to make other improvements as well. Some of the most significant changes are described below.  (limited by the page table entry format); this would allow addressing of up to 4&nbsp;PB of RAM. For comparison, 32-bit x86 processors are limited to 64&nbsp;GB of RAM in Physical Address Extension (PAE) mode, or 4&nbsp;GB of RAM without PAE mode. Although virtual addresses are 64&nbsp;bits wide in 64-bit mode, current implementations (and all chips known to be in the planning stages) do not allow the entire virtual address space of 264 bytes (16&nbsp;EB) to be used. This would be approximately four billion times the size of virtual address space on 32-bit machines. Most operating systems and applications will not need such a large address space for the foreseeable future, so implementing such wide virtual addresses would simply increase the complexity and cost of address translation with no real benefit. AMD therefore decided that, in the first implementations of the architecture, only the least significant 48&nbsp;bits of a virtual address would actually be used in address translation (page table lookup). In addition, the AMD specification requires that bits 48 through 63 of any virtual address must be copies of bit 47 (in a manner akin to sign extension), or the processor will raise an exception. Addresses complying with this rule are referred to as "canonical form." Canonical form addresses run from 0 through 00007FFF'FFFFFFFF, and from FFFF8000'00000000 through FFFFFFFF'FFFFFFFF, for a total of 256&nbsp;TB of usable virtual address space. This is still approximately 64,000 times the virtual address space on 32-bit machines. This feature eases later scalability to true 64-bit addressing. Many operating systems (including, but not limited to, the Windows NT family) take the higher-addressed half of the address space (named kernel space) for themselves and leave the lower-addressed half (user space) for application code, user mode stacks, heaps, and other data regions. The "canonical address" design ensures that every AMD64 compliant implementation has, in effect, two memory halves: the lower half starts at 00000000'00000000 and "grows upwards" as more virtual address bits become available, while the higher half is "docked" to the top of the address space and grows downwards. Also, enforcing the "canonical form" of addresses by checking the unused address bits prevents their use by the operating system in tagged pointers as flags, privilege markers, etc., as such use could become problematic when the architecture is extended to implement more virtual address bits. The first versions of Windows for x64 did not even use the full 256&nbsp;TB; they were restricted to just 8&nbsp;TB of user space and 8&nbsp;TB of kernel space. Windows did not support the entire 48-bit address space until Windows&nbsp;8.1, which was released in October 2013. The 64-bit addressing mode ("long mode") is a superset of Physical Address Extensions (PAE); because of this, page sizes may be 4&nbsp;KB (212 bytes) or 2&nbsp;MB (221 bytes). Long mode also supports page sizes of 1&nbsp;GB (230 bytes). Rather than the three-level page table system used by systems in PAE mode, systems running in long mode use four levels of page table: PAE's Page-Directory Pointer Table is extended from 4 entries to 512, and an additional Page-Map Level&nbsp;4 (PML4) Table is added, containing 512 entries in 48-bit implementations. In implementations providing larger virtual addresses, this latter table would either grow to accommodate sufficient entries to describe the entire address range, up to a theoretical maximum of 33,554,432 entries for a 64-bit implementation, or be over ranked by a new mapping level, such as a PML5. A full mapping hierarchy of 4&nbsp;KB pages for the whole 48-bit space would take a bit more than 512&nbsp;GB of RAM (about 0.195% of the 256&nbsp;TB virtual space). The operating system can also limit the virtual address space. Details, where applicable, are given in the "Operating system compatibility and characteristics" section. Current AMD64 implementations support a physical address space of up to 248 bytes of RAM, or 256&nbsp;TB. A larger amount of installed RAM allows the operating system to keep more of the workload's pageable data and code in RAM, which can improve performance, though various workloads will have different points of diminishing returns. The upper limit on RAM that can be used in a given x86-64 system depends on a variety of factors and can be far less than that implemented by the processor. For example, as of June 2010, there are no known motherboards for x86-64 processors that support 256&nbsp;TB of RAM. The operating system may place additional limits on the amount of RAM that is usable or supported. Details on this point are given in the "Operating system compatibility and characteristics" section of this article. The traditional x87 FPU register stack is not included in the register file size extension in 64-bit mode, compared with the XMM registers used by SSE2, which did get extended. The x87 register stack is not a simple register file although it does allow direct access to individual registers by low cost exchange operations. Also note that 16-bit code written for the 80286 and below cannot use the 32-bit general-purpose registers (GPRs). 16-bit code written for the 80386 and above can use 32-bit GPRs, but defaults to using 16-bit operands. The architecture has two primary modes of operation, long mode and legacy mode. The architecture's intended primary mode of operation; it is a combination of the processor's native 64-bit mode and a combined 32-bit and 16-bit compatibility mode. It is used by 64-bit operating systems. Under a 64-bit operating system, 64-bit programs run under 64-bit mode, and 32-bit and 16-bit protected mode applications (that do not need to use either real mode or virtual 8086 mode in order to execute at any time) run under compatibility mode. Real-mode programs and programs that use virtual 8086 mode at any time cannot be run in long mode unless those modes are emulated in software. However, such programs may be started from an operating system running in long mode on processors supporting VT-x or AMD-V by creating a virtual processor running in the desired mode. Since the basic instruction set is the same, there is almost no performance penalty for executing protected mode x86 code. This is unlike Intel's IA-64, where differences in the underlying instruction set means that running 32-bit code must be done either in emulation of x86 (making the process slower) or with a dedicated x86 processor. However, on the x86-64 platform, many x86 applications could benefit from a 64-bit recompile, due to the additional registers in 64-bit code and guaranteed SSE2-based FPU support, which a compiler can use for optimization. However, applications that regularly handle integers wider than 32 bits, such as cryptographic algorithms, will need a rewrite of the code handling the huge integers in order to take advantage of the 64-bit registers. The mode used by 16-bit ('protected mode' or 'real mode') and 32-bit operating systems. In this mode, the processor acts like a 32-bit x86 processor, and only 16-bit and 32-bit code can be executed. Legacy mode allows for a maximum of 32&nbsp;bit virtual addressing which limits the virtual address space to 4&nbsp;GB. 64-bit programs cannot be run from legacy mode. Intel&nbsp;64 is Intel's implementation of x86-64, used and implemented in various processors made by Intel. Historically, AMD has developed and produced processors with instruction sets patterned after Intel's original designs, but with x86-64, roles were reversed: Intel found itself in the position of adopting the ISA which AMD had created as an extension to Intel's own x86 processor line. Intel's project was originally codenamed Yamhill (after the Yamhill River in Oregon's Willamette Valley). After several years of denying its existence, Intel announced at the February 2004 IDF that the project was indeed underway. Intel's chairman at the time, Craig Barrett, admitted that this was one of their worst-kept secrets."A Roundup of 64-Bit Computing", from internetnews.com Intel's name for this instruction set has changed several times. The name used at the IDF was CT (presumably for Clackamas Technology, another codename from an Oregon river); within weeks they began referring to it as IA-32e (for IA-32 extensions) and in March 2004 unveiled the "official" name EM64T (Extended Memory 64 Technology). In late 2006 Intel began instead using the name Intel&nbsp;64 for its implementation, paralleling AMD's use of the name AMD64. The first processor to implement Intel&nbsp;64 was the multi-socket processor Xeon code-named Nocona in June 2004. In contrast, the initial Prescott chips (February 2004) did not enable this feature. Intel subsequently began selling Intel&nbsp;64-enabled Pentium 4s using the E0 revision of the Prescott core, being sold on the OEM market as the Pentium 4, model F. The E0 revision also adds eXecute Disable (XD) (Intel's name for the NX bit) to Intel&nbsp;64, and has been included in then current Xeon code-named Irwindale. Intel's official launch of Intel&nbsp;64 (under the name EM64T at that time) in mainstream desktop processors was the N0 stepping Prescott-2M. The first Intel mobile processor implementing Intel&nbsp;64 is the Merom version of the Core 2 processor, which was released on July 27, 2006. None of Intel's earlier notebook CPUs (Core Duo, Pentium M, Celeron M, Mobile Pentium 4) implement Intel&nbsp;64. Intel's processors implementing the Intel64 architecture include the Pentium 4 F-series/5x1 series, 506, and 516, Celeron D models 3x1, 3x6, 355, 347, 352, 360, and 365 and all later Celerons, all models of Xeon since "Nocona", all models of Pentium Dual-Core processors since "Merom-2M", the Atom 230, 330, D410, D425, D510, D525, N450, N455, N470, N475, N550, N570, N2600 and N2800, and all versions of the Pentium D, Pentium Extreme Edition, Core&nbsp;2, Core&nbsp;i7, Core&nbsp;i5, and Core&nbsp;i3 processors. VIA Technologies introduced their version of the x86-64 architecture in 2008 after five years of development by its CPU division, Centaur Technology. Codenamed "Isaiah", the 64-bit architecture was unveiled on January 24, 2008, and launched on May 29 under the VIA Nano brand name. The processor supports a number of VIA-specific x86 extensions designed to boost efficiency in low-power appliances. It is expected that the Isaiah architecture will be twice as fast in integer performance and four times as fast in floating-point performance as the previous-generation VIA Esther at an equivalent clock speed. Power consumption is also expected to be on par with the previous-generation VIA CPUs, with thermal design power ranging from 5&nbsp;W to 25&nbsp;W. Being a completely new design, the Isaiah architecture was built with support for features like the x86-64 instruction set and x86 virtualization which were unavailable on its predecessors, the VIA C7 line, while retaining their encryption extensions. Although nearly identical, there are some differences between the two instruction sets in the semantics of a few seldom used machine instructions (or situations), which are mainly used for system programming. Compilers generally produce executables (i.e. machine code) that avoid any differences, at least for ordinary application programs. This is therefore of interest mainly to developers of compilers, operating systems and similar, which must deal with individual and special system instructions. In supercomputers tracked by TOP500, the appearance of 64-bit extensions for the x86 architecture enabled 64-bit x86 processors by AMD and Intel (light olive with circles, and red with circles on the diagram provided in this section, respectively) to replace most RISC processor architectures previously used in such systems (including PA-RISC, SPARC, Alpha and others), as well as 32-bit x86 (green with dots and purple with dots on the diagram), even though Intel itself initially tried unsuccessfully to replace x86 with a new incompatible 64-bit architecture in the Itanium processor. , the main non-x86 CPU architecture which is still used in supercomputing is the Power Architecture used by IBM POWER microprocessors (blue with a diamond pattern on the diagram), with SPARC being far behind in numbers on TOP500, while recently a Fujitsu SPARC64 VIIIfx based supercomputer without co-processors reached number one that is still in the top ten. Non-CPU architecture co-processors (GPGPU) have also played a big role in performance. Intel's Xeon Phi coprocessors, which implement a subset of x86-64 with some vector extensions, are also used, along with x86-64 processors, in the Tianhe-2 supercomputer. The following operating systems and releases support the x86-64 architecture in long mode. Preliminary infrastructure work was started in February 2004 for a x86-64 port. This development later stalled. Development started again during July 2007 and continued during Google Summer of Code 2008 and SoC 2009. The first official release to contain x86-64 support was version 2.4. FreeBSD first added x86-64 support under the name "amd64" as an experimental architecture in 5.1-RELEASE in June 2003. It was included as a standard distribution architecture as of 5.2-RELEASE in January 2004. Since then, FreeBSD has designated it as a Tier&nbsp;1 platform. The 6.0-RELEASE version cleaned up some quirks with running x86 executables under amd64, and most drivers work just as they do on the x86 architecture. Work is currently being done to integrate more fully the x86 application binary interface (ABI), in the same manner as the Linux 32-bit ABI compatibility currently works. x86-64 architecture support was first committed to the NetBSD source tree on June 19, 2001. As of NetBSD&nbsp;2.0, released on December 9, 2004, NetBSD/amd64 is a fully integrated and supported port. 32-bit code is still supported in 64-bit mode, with a netbsd-32 kernel compatibility layer for 32-bit syscalls. The NX bit is used to provide non-executable stack and heap with per-page granularity (segment granularity being used on 32-bit x86). OpenBSD has supported AMD64 since OpenBSD 3.5, released on May 1, 2004. Complete in-tree implementation of AMD64 support was achieved prior to the hardware's initial release because AMD had loaned several machines for the project's hackathon that year. OpenBSD developers have taken to the platform because of its support for the NX bit, which allowed for an easy implementation of the W^X feature. The code for the AMD64 port of OpenBSD also runs on Intel 64 processors which contains cloned use of the AMD64 extensions, but since Intel left out the page table NX bit in early Intel 64 processors, there is no W^X capability on those Intel CPUs; later Intel 64 processors added the NX bit under the name "XD bit". Symmetric multiprocessing (SMP) works on OpenBSD's AMD64 port, starting with release 3.6 on November 1, 2004. It is possible to enter long mode under DOS without a DOS extender,Tutorial for entering protected and long mode from DOS but the user must return to real mode in order to call BIOS or DOS interrupts. It may also be possible to enter long mode with a DOS extender similar to DOS/4GW, but more complex since x86-64 lacks virtual 8086 mode. DOS itself is not aware of that, and no benefits should be expected unless running DOS in an emulation with an adequate virtualization driver backend, for example: the mass storage interface. Linux was the first operating system kernel to run the x86-64 architecture in long mode, starting with the 2.4 version in 2001 (preceding the hardware's availability). Linux also provides backward compatibility for running 32-bit executables. This permits programs to be recompiled into long mode while retaining the use of 32-bit programs. Several Linux distributions currently ship with x86-64-native kernels and userlands. Some, such as Arch Linux, SUSE, Mandriva, and Debian allow users to install a set of 32-bit components and libraries when installing off a 64-bit DVD, thus allowing most existing 32-bit applications to run alongside the 64-bit OS. Other distributions, such as Fedora, Slackware and Ubuntu, are available in one version compiled for a 32-bit architecture and another compiled for a 64-bit architecture. Fedora and Red Hat Enterprise Linux allow concurrent installation of all userland components in both 32 and 64-bit versions on a 64-bit system. x32 ABI (Application Binary Interface), introduced in Linux 3.4, allows programs compiled for the x32 ABI to run in the 64-bit mode of x86-64 while only using 32-bit pointers and data fields. Though this limits the program to a virtual address space of 4&nbsp;GB it also decreases the memory footprint of the program and in some cases can allow it to run faster. 64-bit Linux allows up to 128&nbsp;TB of virtual address space for individual processes, and can address approximately 64&nbsp;TB of physical memory, subject to processor and system limitations. Mac OS X v10.4.7 and higher versions of Mac OS X v10.4 run 64-bit command-line tools using the POSIX and math libraries on 64-bit Intel-based machines, just as all versions of Mac OS X v10.4 and 10.5 run them on 64-bit PowerPC machines. No other libraries or frameworks work with 64-bit applications in Mac OS X v10.4. The kernel, and all kernel extensions, are 32-bit only. Mac OS X v10.5 supports 64-bit GUI applications using Cocoa, Quartz, OpenGL, and X11 on 64-bit Intel-based machines, as well as on 64-bit PowerPC machines. All non-GUI libraries and frameworks also support 64-bit applications on those platforms. The kernel, and all kernel extensions, are 32-bit only. Mac OS X v10.6 is the first version of OS X that supports a 64-bit kernel. However, not all 64-bit computers can run the 64-bit kernel, and not all 64-bit computers that can run the 64-bit kernel will do so by default. The 64-bit kernel, like the 32-bit kernel, supports 32-bit applications; both kernels also support 64-bit applications. 32-bit applications have a virtual address space limit of 4&nbsp;GB under either kernel. OS X v10.8 includes only the 64-bit kernel, but continues to support 32-bit applications. The 64-bit kernel does not support 32-bit kernel extensions, and the 32-bit kernel does not support 64-bit kernel extensions. OS X uses the universal binary format to package 32- and 64-bit versions of application and library code into a single file; the most appropriate version is automatically selected at load time. In Mac OS X 10.6, the universal binary format is also used for the kernel and for those kernel extensions that support both 32-bit and 64-bit kernels.  Solaris 10 and later releases support the x86-64 architecture. For Solaris 10, just as with the SPARC architecture, there is only one operating system image, which contains a 32-bit kernel and a 64-bit kernel; this is labeled as the "x64/x86" DVD-ROM image. The default behavior is to boot a 64-bit kernel, allowing both 64-bit and existing or new 32-bit executables to be run. A 32-bit kernel can also be manually selected, in which case only 32-bit executables will run. The isainfo command can be used to determine if a system is running a 64-bit kernel. For Solaris 11, only the 64-bit kernel is provided. However, the 64-bit kernel supports both 32- and 64-bit executables, libraries, and system calls. x64 editions of Microsoft Windows client and server—Windows XP Professional x64 Edition and Windows Server 2003 x64 Edition—were released in March 2005. Internally they are actually the same build (5.2.3790.1830 SP1), as they share the same source base and operating system binaries, so even system updates are released in unified packages, much in the manner as Windows 2000 Professional and Server editions for x86. Windows Vista, which also has many different editions, was released in January 2007. Windows&nbsp;7 was released in July 2009. Windows Server 2008 R2 was sold in only x64 and Itanium editions; later versions of Windows Server only offer an x64 edition. Versions of Windows for x64 prior to Windows 8.1 and Windows Server 2012 R2 offer the following: Under Windows 8.1 and Windows Server 2012 R2, both user mode and kernel mode virtual address spaces have been extended to 128&nbsp;TB. These versions of Windows will not install on processors that lack the CMPXCHG16B instruction. The following additional characteristics apply to all x64 versions of Windows: PlayStation 4 and Xbox One include Jaguar, a multi-core processor designed by AMD. Both use x86-64 to address 8&nbsp;GB of RAM. Since AMD64 and Intel 64 are substantially similar, many software and hardware products use one vendor-neutral term to indicate their compatibility with both implementations. AMD's original designation for this processor architecture, "x86-64", is still sometimes used for this purpose, as is the variant "x86_64". Other companies, such as Microsoft and Sun Microsystems/Oracle Corporation, use the contraction "x64" in marketing material. The term IA-64 refers to the Itanium processor, and should not be confused with x86-64, as it is a completely different instruction set. Many operating systems and products, especially those that introduced x86-64 support prior to Intel's entry into the market, use the term "AMD64" or "amd64" to refer to both AMD64 and Intel 64. Intel licenses to AMD the right to use the original x86 architecture (upon which AMD's x86-64 is based). In 2009, AMD and Intel settled several lawsuits and cross-licensing disagreements, extending their cross-licensing agreements. Operating mode Operating sub-mode Operating system required Type of code being run Default address size Default operand size Supported typical operand sizes Register file size Typical GPR width Long mode 64-bit mode 64-bit operating system or boot loader 64-bit code 64 bits 32 bits 8, 16, 32, or 64 bits 16 registers per file 64 bits Compatibility mode 64-bit operating system or boot loader 32-bit protected mode code 32 bits 32 bits 8, 16, or 32 bits 8 registers per file 32 bits 64-bit operating system 16-bit protected mode code 16 bits 16 bits 8, 16, or 32 bits 8 registers per file 32 bits Legacy mode Protected mode 32-bit operating system or boot loader, or 64-bit boot loader 32-bit protected mode code 32 bits 32 bits 8, 16, or 32 bits 8 registers per file 32 bits 16-bit protected mode operating system or boot loader, or 32- or 64-bit boot loader 16-bit protected mode code 16 bits 16 bits 8, 16, or 32 bits 8 registers per file 16 or 32 bits Virtual 8086 mode 16- or 32-bit protected mode operating system 16-bit real mode code 16 bits 16 bits 8, 16, or 32 bits 8 registers per file 16 or 32 bits Real mode 16-bit real mode operating system or boot loader, or 32- or 64-bit boot loader 16-bit real mode code 16 bits 16 bits 8, 16, or 32 bits 8 registers per file 16 or 32 bits All general-purpose registers (GPRs) are expanded from 32&nbsp;bits to 64&nbsp;bits, and all arithmetic and logical operations, memory-to-register and register-to-memory operations, etc., can now operate directly on 64-bit integers. Pushes and pops on the stack default to 8-byte strides, and pointers are 8 bytes wide. In addition to increasing the size of the general-purpose registers, the number of named general-purpose registers is increased from eight (i.e. eax, ebx, ecx, edx, ebp, esp, esi, edi) in x86 to 16 (i.e. rax, rbx, rcx, rdx, rbp, rsp, rsi, rdi, r8, r9, r10, r11, r12, r13, r14, r15). It is therefore possible to keep more local variables in registers rather than on the stack, and to let registers hold frequently accessed constants; arguments for small and fast subroutines may also be passed in registers to a greater extent. AMD64 still has fewer registers than many common RISC instruction sets (which typically have 32&nbsp;registers) or VLIW-like machines such as the IA-64 (which has 128&nbsp;registers). However, an AMD64 implementation may have far more internal registers than the number of architectural registers exposed by the instruction set (see register renaming). Similarly, the number of 128-bit XMM registers (used for Streaming SIMD instructions) is also increased from 8 to 16. The AMD64 architecture defines a 64-bit virtual address format, of which the low-order 48 bits are used in current implementations. This allows up to 256&nbsp;TB (248 bytes) of virtual address space. The architecture definition allows this limit to be raised in future implementations to the full 64 bits, extending the virtual address space to 16&nbsp;EB (264 bytes). This is compared to just 4&nbsp;GB (232 bytes) for the x86. This means that very large files can be operated on by mapping the entire file into the process' address space (which is often much faster than working with file read/write calls), rather than having to map regions of the file into and out of the address space. The original implementation of the AMD64 architecture implemented 40-bit physical addresses and so could address up to 1&nbsp;TB (240 bytes) of RAM. Current implementations of the AMD64 architecture (starting from AMD 10h microarchitecture)  extend this to 48-bit physical addresses  and therefore can address up to 256&nbsp;TB of RAM. The architecture permits extending this to 52 bits in the future When operating in legacy mode the AMD64 architecture supports Physical Address Extension (PAE) mode, as do most current x86 processors, but AMD64 extends PAE from 36 bits to an architectural limit of 52&nbsp;bits of physical address. Any implementation therefore allows the same physical address limit as under long mode. Instructions can now reference data relative to the instruction pointer (RIP register). This makes position independent code, as is often used in shared libraries and code loaded at run time, more efficient. The original AMD64 architecture adopted Intel's SSE and SSE2 as core instructions. These instruction sets provide a vector supplement to the scalar x87 FPU, for the single-precision and double-precision data types. SSE2 also offers integer vector operations, for data types ranging from 8bit to 64bit precision. This makes the vector capabilities of the architecture on par with those of the most advanced x86 processors of its time. These instructions can also be used in 32-bit mode. The proliferation of 64-bit processors has made these vector capabilities ubiquitous in home computers, allowing the improvement of the standards of 32-bit applications. The 32-bit edition of Windows 8, for example, requires the presence of SSE2 instructions on the computers it is installed. SSE3 instructions and later Streaming SIMD Extensions instruction sets are not standard features of the architecture. The No-Execute bit or NX bit (bit 63 of the page table entry) allows the operating system to specify which pages of virtual address space can contain executable code and which cannot. An attempt to execute code from a page tagged "no execute" will result in a memory access violation, similar to an attempt to write to a read-only page. This should make it more difficult for malicious code to take control of the system via "buffer overrun" or "unchecked buffer" attacks. A similar feature has been available on x86 processors since the 80286 as an attribute of segment descriptors; however, this works only on an entire segment at a time. Segmented addressing has long been considered an obsolete mode of operation, and all current PC operating systems in effect bypass it, setting all segments to a base address of zero and (in their 32 bit implementation) a size of 4&nbsp;GB. AMD was the first x86-family vendor to implement no-execute in linear addressing mode. The feature is also available in legacy mode on AMD64 processors, and recent Intel x86 processors, when PAE is used. A few "system programming" features of the x86 architecture are not used in modern operating systems and are not available on AMD64 in long (64-bit and compatibility) mode. These include segmented addressing (although the FS and GS segments are retained in vestigial form for use as extra base pointers to operating system structures), the task state switch mechanism, and virtual 8086 mode. These features remain fully implemented in "legacy mode", allowing these processors to run 32-bit and 16-bit operating systems without modifications. Some instructions that proved to be rarely useful are not supported in 64-bit mode, including saving/restoring of segment registers on the stack, saving/restoring of all registers (PUSHA/POPA), decimal arithmetic, BOUND and INTO instructions, and "far" jumps and calls with immediate operands. Intel&nbsp;64's BSF and BSR instructions act differently than AMD64's when the source is zero and the operand size is 32&nbsp;bits. The processor sets the zero flag and leaves the upper 32&nbsp;bits of the destination undefined. AMD64 requires a different microcode update format and control MSRs (model-specific registers) while Intel&nbsp;64 implements microcode update unchanged from their 32-bit only processors. Intel&nbsp;64 lacks some MSRs that are considered architectural in AMD64. These include SYSCFG, TOP_MEM, and TOP_MEM2. Intel&nbsp;64 allows SYSCALL/SYSRET only in 64-bit mode (not in compatibility mode), and allows SYSENTER/SYSEXIT in both modes. AMD64 lacks SYSENTER/SYSEXIT in both sub-modes of long mode. In 64-bit mode, near branches with the 66H (operand size override) prefix behave differently. Intel&nbsp;64 ignores this prefix: the instruction has 32-bit sign extended offset, and instruction pointer is not truncated. AMD64 uses 16-bit offset field in the instruction, and clears the top 48&nbsp;bits of instruction pointer. AMD processors raise a floating point Invalid Exception when performing an FLD or FSTP of an 80-bit signalling NaN, while Intel processors do not. Intel&nbsp;64 lacks the ability to save and restore a reduced (and thus faster) version of the floating-point state (involving the FXSAVE and FXRSTOR instructions). Recent AMD64 processors have reintroduced limited support for segmentation, via the Long Mode Segment Limit Enable (LMSLE) bit, to ease virtualization of 64-bit guests. When returning to a non-canonical address using SYSRET, AMD64 processors execute the general protection fault handler in privilege level 3, while on Intel&nbsp;64 processors it is executed in privilege level 0. Early AMD64 processors (typically on Socket 939 and 940) lacked the CMPXCHG16B instruction, which is an extension of the CMPXCHG8B instruction present on most post-80486 processors. Similar to CMPXCHG8B, CMPXCHG16B allows for atomic operations on octal words. This is useful for parallel algorithms that use compare and swap on data larger than the size of a pointer, common in lock-free and wait-free algorithms. Without CMPXCHG16B one must use workarounds, such as a critical section or alternative lock-free approaches. Its absence also prevents 64-bit Windows prior to Windows 8.1 from having a user-mode address space larger than 8&nbsp;terabytes."http://blogs.msdn.com/b/oldnewthing/archive/2006/11/22/1122581.aspx" The Old New Thing, by Raymond Chen (see bottom paragraph of blog post) The 64-bit version of Windows 8.1 requires the instruction. Early AMD64 and Intel&nbsp;64 CPUs lacked LAHF and SAHF instructions in 64-bit mode. AMD introduced these instructions (also in 64-bit mode) with their Athlon&nbsp;64, Opteron and Turion&nbsp;64 revision&nbsp;D processors in March 2005"Revision Guide for AMD Athlon&nbsp;64 and AMD Opteron Processors", from AMD"AMD Turion&nbsp;64 pictured up and running", from The Inquirer"Athlon&nbsp;64 revision&nbsp;E won't work on some Nforce 3/4 boards", from The Inquirer while Intel introduced the instructions with the Pentium&nbsp;4&nbsp;G1 stepping in December 2005. The 64-bit version of Windows 8.1 requires this feature. Early Intel CPUs with Intel&nbsp;64 also lack the NX bit of the AMD64 architecture. This feature is required by all versions of Windows 8.x. Early Intel&nbsp;64 implementations (Prescott and Cedar Mill) only allowed access to 64&nbsp;GB of physical memory while original AMD64 implementations allowed access to 1&nbsp;TB of physical memory. Recent AMD64 implementations provide 256&nbsp;TB of physical address space (and AMD plans an expansion to 4&nbsp;PB), while some Intel&nbsp;64 implementations could address up to 64&nbsp;TB."Intel 64 architecture increases the linear address space for software to 64 bits and supports physical address space up to 46 bits." on page Vol. 1 2-21 of Intel 64 and IA-32 Architectures Software Developer’s Manual September 2014 Physical memory capacities of this size are appropriate for large-scale applications (such as large databases), and high-performance computing (centrally oriented applications and scientific computing). 8&nbsp;TB of virtual address space per process, accessible from both user mode and kernel mode, referred to as the user mode address space. An x64 program can use all of this, subject to backing store limits on the system, and provided it is linked with the "large address aware" option. This is a 4096-fold increase over the default 2&nbsp;GB user-mode virtual address space offered by 32-bit Windows. 8&nbsp;TB of kernel mode virtual address space for the operating system. As with the user mode address space, this is a 4096-fold increase over 32-bit Windows versions. The increased space primarily benefits the file system cache and kernel mode "heaps" (non-paged pool and paged pool). Windows only uses a total of 16&nbsp;TB out of the 256&nbsp;TB implemented by the processors because early AMD64 processors lacked a CMPXCHG16B instruction. Ability to run existing 32-bit applications (.exe programs) and dynamic link libraries (.dlls) using WoW64 if WoW64 is supported on that version. Furthermore, a 32-bit program, if it was linked with the "large address aware" option, can use up to 4&nbsp;GB of virtual address space in 64-bit Windows, instead of the default 2&nbsp;GB (optional 3&nbsp;GB with /3GB boot option and "large address aware" link option) offered by 32-bit Windows. Unlike the use of the /3GB boot option on x86, this does not reduce the kernel mode virtual address space available to the operating system. 32-bit applications can therefore benefit from running on x64 Windows even if they are not recompiled for x86-64. Both 32- and 64-bit applications, if not linked with "large address aware," are limited to 2&nbsp;GB of virtual address space. Ability to use up to 128&nbsp;GB (Windows XP/Vista), 192&nbsp;GB (Windows&nbsp;7), 512&nbsp;GB (Windows&nbsp;8), 1&nbsp;TB (Windows Server 2003), 2&nbsp;TB (Windows Server 2008), or 4&nbsp;TB (Windows Server 2012) of physical random access memory (RAM). LLP64 data model: "int" and "long" types are 32&nbsp;bits wide, long long is 64&nbsp;bits, while pointers and types derived from pointers are 64&nbsp;bits wide. Kernel mode device drivers must be 64-bit versions; there is no way to run 32-bit kernel mode executables within the 64-bit operating system. User mode device drivers can be either 32-bit or 64-bit. 16-bit Windows (Win16) and DOS applications will not run on x86-64 versions of Windows due to removal of the virtual DOS machine subsystem (NTVDM) which relied upon the ability to use virtual 8086 mode. Virtual 8086 mode cannot be entered while running in long mode. Full implementation of the NX (No Execute) page protection feature. This is also implemented on recent 32-bit versions of Windows when they are started in PAE mode. Instead of FS segment descriptor on x86 versions of the Windows NT family, GS segment descriptor is used to point to two operating system defined structures: Thread Information Block (NT_TIB) in user mode and Processor Control Region (KPCR) in kernel mode. Thus, for example, in user mode GS:0 is the address of the first member of the Thread Information Block. Maintaining this convention made the x86-64 port easier, but required AMD to retain the function of the FS and GS segments in long mode — even though segmented addressing per se is not really used by any modern operating system. Early reports claimed that the operating system scheduler would not save and restore the x87 FPU machine state across thread context switches. Observed behavior shows that this is not the case: the x87 state is saved and restored, except for kernel mode-only threads (a limitation that exists in the 32-bit version as well). The most recent documentation available from Microsoft states that the x87/MMX/3DNow! instructions may be used in long mode, but that they are deprecated and may cause compatibility problems in the future. Some components like Microsoft Jet Database Engine and Data Access Objects will not be ported to 64-bit architectures such as x86-64 and IA-64.Microsoft Developer Network – General Porting Guidelines (64-bit Windows Programming)Microsoft Developer Network – Data Access Road Map Microsoft Visual Studio can compile native applications to target either the x86-64 architecture, which can run only on 64-bit Microsoft Windows, or the IA-32 architecture, which can run as a 32-bit application on 32-bit Microsoft Windows or 64-bit Microsoft Windows in WoW64 emulation mode. Managed applications can be compiled either in IA-32, x86-64 or AnyCPU modes. Software created in the first two modes behave like their IA-32 or x86-64 native code counterparts respectively; When using the AnyCPU mode however, applications in 32-bit versions of Microsoft Windows run as 32-bit applications, while they run as a 64-bit application in 64-bit editions of Microsoft Windows. amd64 Most BSD systems such as FreeBSD, MidnightBSD, NetBSD and OpenBSD refer to both AMD64 and Intel 64 under the architecture name "amd64". Some Linux distros such as Debian, Ubuntu, and Gentoo refer to both AMD64 and Intel 64 under the architecture name "amd64". Microsoft Windows's x64 versions use the AMD64 moniker internally to designate various components which use or are compatible with this architecture. For example, the environment variable PROCESSOR_ARCHITECTURE is assigned the value "AMD64" as opposed to "x86" in 32-bit versions, and the system directory on a Windows x64 Edition installation CD-ROM is named "AMD64", in contrast to "i386" in 32-bit versions.ProcessorArchitecture Fields Sun's Solaris' isalist command identifies both AMD64- and Intel 64-based systems as "amd64". x86_64 The Linux kernel and the GNU Compiler Collection refers to 64-bit architecture as "x86_64". Some Linux distros, such as Fedora, openSUSE, and Arch Linux refer to this 64-bit architecture as "x86_64". Apple OS X refers to 64-bit architecture as "x86-64" or "x86_64", as seen in the Terminal command arch and in their developer documentation. Java Development Kit (JDK): the name "amd64" is used in directory names containing x86-64 files. Breaking with most other BSD systems, DragonFly BSD refers to 64-bit architecture as "x86_64". Haiku refers to 64-bit architecture as "x86_64". AMD Generic Encapsulated Software Architecture (AGESA) X32 ABI AMD's AMD64 Developer Guides and Manuals x86-64: Extending the x86 architecture to 64-bits – technical talk by the architect of AMD64 (video archive), and second talk by the same speaker (video archive) AMD's "Enhanced Virus Protection" Intel tweaks EM64T for full AMD64 compatibility Analyst: Intel Reverse-Engineered AMD64 Early report of differences between Intel IA32e and AMD64 Porting to 64-bit GNU/Linux Systems, by Andreas Jaeger from GCC Summit 2003 [ ]. An excellent paper explaining almost all practical aspects for a transition from 32-bit to 64-bit. Tech Report article: 64-bit computing in theory and practice Intel 64 Architecture Intel Software Network: "64 bits" TurboIRC.COM tutorial of entering the protected and the long mode the raw way from DOS Optimization of 64-bit programs Seven Steps of Migrating a Program to a 64-bit System Memory Limits for Windows Releases
